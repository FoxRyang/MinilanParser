
//
//  This is the helper file for the RealTree example
//  program.  It is an example program for use of the
//  GPPG parser generator.  Copyright (c) K John Gough 2012
//

using System;
using System.Collections.Generic;
using System.Text;
using QUT.Gppg;
using System.IO;

namespace RealTree
{
    //
    // There are several classes defined here.
    //
    // The parser class is named Parser (the gppg default),
    // and contains a handwritten scanner with class name
    // RealTree.Parser.Lexer.
    //
    // The Parser class is partial, so that most of the 
    // handwritten code may be placed in this file in a
    // second part of the class definition.
    //
    // This file also contains the class hierarchy for the
    // semantic action class RealTree.Node
    //
    // The token enumeration RealTree.Parser.Tokens (also
    // the gppg default) is generated by gppg.
    //
    internal partial class Parser
    {

        // 
        // GPPG does not create a default parser constructor
        // Most applications will have a parser type with other
        // fields such as error handlers etc.  Here is a minimal
        // version that just adds the default scanner object.
        // 

        Parser(Lexer s) : base(s) { }

        internal Node[] regs = new Node[26];

        // ==================================================================================

        static void Main(string[] args)
        {
            System.IO.TextReader reader;
            if (args.Length > 0)
                reader = new System.IO.StreamReader(args[0]);
            else
                reader = System.Console.In;

            FileStream fsa = new FileStream(Directory.GetCurrentDirectory() + "/test.txt", FileMode.Open);
            reader = new StreamReader(fsa);

            StreamWriter output = new StreamWriter(Directory.GetCurrentDirectory() + "/output.txt");
            


            Parser parser = new Parser(new Lexer(reader));
            Console.WriteLine("RealCalc expression evaluator, type ^C to exit, help for help");
            parser.Parse();

            System.Console.Write(parser.ValueStack[1].Unparse());
            String str = parser.ValueStack[1].Unparse();
            output.WriteLine(str);

            output.Close();
        }

        // ==================================================================================
        //  Version for real arithmetic.  YYSTYPE is RealTree.Node
        //  This version uses an embedded scanner rather than a gplex-generated one.
        //
        class Lexer : QUT.Gppg.AbstractScanner<RealTree.Node, LexLocation>
        {
            private System.IO.TextReader reader;
            private StringBuilder text = new StringBuilder();

            public Lexer(System.IO.TextReader reader)
            {
                this.reader = reader;
            }

            private LexLocation singleton = new LexLocation();
            public override LexLocation yylloc
            {
                get { return singleton; }
            }

			int linenum = 0;

            public override int yylex()
            {
                char ch;
                char peek;
                int ord = reader.Read();
                //this.text.Clear();
                this.text.Length = 0;
                //
                // Must check for EOF
                //
                if (ord == -1)
                    return (int)Tokens.EOF;
                else
                    ch = (char)ord;

                if (ch == '\n') {
                    linenum++;
                    return yylex();
                } else if (char.IsWhiteSpace(ch)) { // Skip white space
                    while (char.IsWhiteSpace(peek = (char)reader.Peek())) {
                        ord = reader.Read();
                        if (ord == (int)'\n') {
                            linenum++;
                            continue;
                        }
                    }
                    return yylex();
                } else if (char.IsDigit(ch)) {
                    text.Append(ch);
                    while (char.IsDigit(peek = (char)reader.Peek()))
                        text.Append((char)reader.Read());
                    if ((peek = (char)reader.Peek()) == '.')
                        text.Append((char)reader.Read());
                    while (char.IsDigit(peek = (char)reader.Peek()))
                        text.Append((char)reader.Read());
                    try {
                        yylval = Parser.MakeNumLeaf(double.Parse(text.ToString()));
                        return (int)Tokens.NUMBER;
                    } catch (FormatException) {
                        this.yyerror("Illegal number \"{0}\"", text);
                        return (int)Tokens.error;
                    }
                } else if (char.IsLetter(ch)) {
                    text.Append(char.ToLower(ch));
                    while (char.IsLetter(peek = (char)reader.Peek()))
                        text.Append(char.ToLower((char)reader.Read()));
                    switch (text.ToString()) {
                        case "if":
                            return (int)Tokens.IF;
                        case "fi":
                            return (int)Tokens.END_IF;
                        case "do":
                            return (int)Tokens.DO;
                        case "od":
                            return (int)Tokens.END_DO;
                        default:
                            if (text.Length == 1) {
                                yylval = Parser.MakeIdLeaf(text[0]);
                                return (int)Tokens.ID;
                            } else {
                                this.yyerror("Illegal name \"{0}\"", text);
                                return (int)Tokens.error;
                            }
                    }
                } else
                    switch (ch) {
                        case '.':
                        case '+':
                        case '-':
                        case '*':
                        case '/':
                        case '(':
                        case ')':
                        case '%':
                        case '=':
                        case ':':
                        case '>':
                        case '<':
                        case '!':
                        case ',':
                        case ';':
                        case '|':
                            return ch;
                        default:
                            yyerror("Illegal character '{0}' on line '{1}'", ch, linenum);
                            return yylex();
                    }
            }

            public override void yyerror(string format, params object[] args)
            {
                Console.Error.WriteLine(format, args);
            }
        }
        // ==================================================================================
        //  End of Lexer class definition.
        // ==================================================================================

        //
        // Now the node factory methods
        //d
        public static Node MakeBinary(NodeTag tag, Node lhs, Node rhs)
        {
            return new Binary(tag, lhs, rhs);
        }
		
		//d
        public static Node MakeIdLeaf(char n)
        {
            return new Leaf(n);
        }
		//d

		public static Node MakeUnIdLeaf(Node node)
        {
            return new Unary(NodeTag.negate, node);
        }

		//d
		public static Node MakeNumLeaf(double b)
        {
            return new Leaf(b);
        }
		
		//d
		public static Node MakeRootNode(Node lhs, Node rhs)
        {
            return new Root(NodeTag.root, lhs, rhs);
        }

		//d
		public static Node MakeSLNode(Node lhs, Node rhs)
        {
            return new SLNode(lhs, rhs);
        }

		//d
        public static Node MakeSkipNode()
        {
            return new Leaf(NodeTag.skip);
        }

		//d
        public static Node MakeAbort()
        {
            return new Leaf(NodeTag.abort);
        }

		//d
        public static Node MakeAssignDeep(Node lhs, Node mid, Node rhs)
        {
            return new AssignNode(lhs, mid, rhs);
        }
		//d
		public static Node MakeAssign(Node lhs, Node rhs)
        {
            return new AssignNode(lhs, null, rhs);
        }
		//d
		public static Node MakeIfSequence(Node node)
        {
            return new IfStatus(node);
        }
		//d
        public static Node MakeDoSequence(Node node)
        {
            return new DoStatus(node);
        }

		//d
        public static Node MakeCondition(Node lhs, Node rhs)
        {
            return new Cond(lhs, rhs);
        }

		//d
		public static Node MakeGaurd(NodeTag tag, Node lhs, Node rhs)
        {
            return new Guard(tag, lhs, rhs);
        }

        // ==================================================================================
        // And the semantic helpers
        // ==================================================================================

        private void ClearRegisters()
        {
            for (int i = 0; i < regs.Length; i++)
                regs[i] = null;
        }

        private void PrintRegisters()
        {
            for (int i = 0; i < regs.Length; i++)
                if (regs[i] != null)
                    Console.WriteLine("regs[{0}] = '{1}' = {2}", i, (char)(i + (int)'a'), regs[i].Unparse());
        }

        private void AssignExpression(Node dst, Node expr)
        {
            Leaf destination = dst as Leaf;
            regs[destination.Index] = expr;
        }

        private void CallExit()
        {
            Console.Error.WriteLine("RealTree will exit");
            System.Environment.Exit(1);
        }

        private double Eval(Node node)
        {
            try {
                return node.Eval(this);
            } catch (CircularEvalException) {
                Scanner.yyerror("Eval has circular dependencies");
            } catch {
                Scanner.yyerror("Invalid expression evaluation");
            }
            return 0.0;
        }

        private void Display(Node node)
        {
            try {
                double result = node.Eval(this);
                Console.WriteLine("result: " + result.ToString());
            } catch (CircularEvalException) {
                Scanner.yyerror("Eval has circular dependencies");
            } catch {
                Scanner.yyerror("Invalid expression evaluation");
            }
        }

        public class CircularEvalException : Exception
        {
            internal CircularEvalException() { }
        }
    }

    // ==================================================================================
    //  Start of Node Definitions
    // ==================================================================================

    internal enum NodeTag { error, name, number, plus, minus, mul, div,
        rem, negate, gt, gte, lt, lte, eq, neq, assign, IF, DO, abort, skip, SL, root, cond }
	
    internal abstract class Node
    {
        readonly NodeTag tag;
        protected bool active = false;
        public NodeTag Tag { get { return this.tag; } }

        protected Node(NodeTag tag)
        {
            this.tag = tag;
        }
        public abstract double Eval(Parser p);
        public abstract string Unparse();
		
        public Node parent = null;

        public void Prolog()
        {
            if (this.active)
                throw new Parser.CircularEvalException();
            this.active = true;
        }

        public void Epilog() { this.active = false; }
    }

	internal class Root : Node
    {
        public Node lhs = null;
        public Node rhs = null;

		internal Root(NodeTag t, Node lhs, Node rhs) : base(t)
        {
            this.lhs = lhs;
            this.rhs = rhs;
        }

        public override double Eval(Parser p)
        {
            try {
                this.Prolog();
                return this.lhs.Eval(p) + this.rhs.Eval(p);
            } finally {
                this.Epilog();
            }
        }

        public override string Unparse()
        {
            return String.Format("[ Root {0}, {1} ]", lhs.Unparse(), rhs.Unparse());
        }
    }

	internal class IfStatus : Node
    {
        Node remain;

		internal IfStatus(Node node) : base(NodeTag.IF)
        {
            remain = node;
        }

        public override double Eval(Parser p)
        {
            return remain.Eval(p);
        }

        public override string Unparse()
        {
            return String.Format("[ If {0} ]", remain.Unparse());
        }
    }

    internal class DoStatus : Node
    {
        Node remain;

        internal DoStatus(Node node) : base(NodeTag.DO)
        {
            remain = node;
        }

        public override double Eval(Parser p)
        {
            return remain.Eval(p);
        }

        public override string Unparse()
        {
            return String.Format("[ Do {0} ]", remain.Unparse());
        }
    }

    internal class SLNode : Node
    {
        Node lhs;
        Node remain;

        internal SLNode(Node lhs, Node remain) : base(NodeTag.SL)
        {
            this.lhs = lhs;
            this.remain = remain;
        }

        public override double Eval(Parser p)
        {
            return remain.Eval(p);
        }

        public override string Unparse()
        {
            if (remain != null) {
                return String.Format("[ SL {0} | {1} ]", lhs.Unparse(), remain.Unparse());
            } else {
                return String.Format("[ SL {0} ]", remain.Unparse());
            }
        }
    }

	internal class Cond : Node
    {
        Node guard;
        Node expr;

		internal Cond(Node lhs, Node rhs) : base(NodeTag.cond)
        {
            guard = lhs;
            expr = rhs;
        }

        public override double Eval(Parser p)
        {
            return expr.Eval(p);
        }

        public override string Unparse()
        {
            return String.Format("[ SL {0} -> {1} ]", guard.Unparse(), expr.Unparse());
        }
    }

	internal class Guard : Node
    {
        Node lhs, rhs;

		internal Guard(NodeTag t, Node lhs, Node rhs) : base(t)
        {
            this.lhs = lhs;
            this.rhs = rhs;
        }

        public override double Eval(Parser p)
        {
			
            return lhs.Eval(p);
        }

        public override string Unparse()
        {
            return String.Format("[ GUARD {0} {1} {2} ]", lhs.Unparse(), Convert(Tag), rhs.Unparse());
        }

        static bool Check(NodeTag t, double a, double b)
        {
            switch (t) {
                case NodeTag.gt:
                    return a > b;
                case NodeTag.gte:
                    return a >= b;
                case NodeTag.eq:
                    return a == b;
                case NodeTag.neq:
                    return a != b;
                case NodeTag.lt:
                    return a < b;
                case NodeTag.lte:
                    return a <= b;
                default: return true;
            }
        }

        static string Convert(NodeTag t)
        {
            switch (t) {
                case NodeTag.gt:
                    return ">";
                case NodeTag.gte:
                    return ">=";
                case NodeTag.eq:
                    return "==";
                case NodeTag.neq:
                    return "!=";
                case NodeTag.lt:
                    return "<";
                case NodeTag.lte:
                    return "<=";
                default: return "<ERROR>";
            }
        }
    }

    internal class AssignNode : Node
    {
        public Node id, expr, remain = null;

		internal AssignNode(Node lhs, Node remain, Node rhs) : base(NodeTag.assign)
        {
            this.id = lhs;
            this.remain = remain;
            this.expr = rhs;
        }

        public override double Eval(Parser p)
        {
            return id.Eval(p);
        }

        public override string Unparse()
        {
            if (remain != null) {
                return String.Format("[AssignCtn {0}, {1}, {2} ]", id.Unparse(), remain.Unparse(), expr.Unparse());
            } else {
                return String.Format("[Assign {0} {1}]", id.Unparse(), expr.Unparse());
            }
        }
    }

    internal class Leaf : Node
    {
        char name;
        double value;
        internal Leaf(char c) : base(NodeTag.name) { this.name = c; }
        internal Leaf(double v) : base(NodeTag.number) { this.value = v; }
		internal Leaf(NodeTag t) : base(t) { }

        public int Index { get { return (int)name - (int)'a'; } }
        public double Value { get { return value; } }

        public override double Eval(Parser p)
        {
            try {
                this.Prolog();
                if (this.Tag == NodeTag.name)
                    return p.regs[this.Index].Eval(p);
                else
                    return this.value;
            } finally {
                this.Epilog();
            }
        }

        public override string Unparse()
        {
            if (Tag == NodeTag.name)
                return this.name.ToString();
            else
                return this.value.ToString();
        }
    }

    internal class Unary : Node
    {
        Node child;
        internal Unary(NodeTag t, Node c)
            : base(t)
        { this.child = c; }

        public override double Eval(Parser p)
        {
            try {
                this.Prolog();
                return -this.child.Eval(p);
            } finally {
                this.Epilog();
            }
        }

        public override string Unparse()
        {
            return String.Format("( - {0})", this.child.Unparse());
        }
    }

    internal class Binary : Node
    {
        Node lhs;
        Node rhs;

        internal Binary(NodeTag t, Node l, Node r) : base(t)
        {
            this.lhs = l; this.rhs = r;
        }

        public override double Eval(Parser p)
        {
            try {
                this.Prolog();
                double lVal = this.lhs.Eval(p);
                double rVal = this.rhs.Eval(p);
                switch (this.Tag) {
                    case NodeTag.div: return lVal / rVal;
                    case NodeTag.minus: return lVal - rVal;
                    case NodeTag.plus: return lVal + rVal;
                    case NodeTag.rem: return lVal % rVal;
                    case NodeTag.mul: return lVal * rVal;
                    default: throw new Exception("bad tag");
                }
            } finally {
                this.Epilog();
            }
        }

        public override string Unparse()
        {
            string op = "";
            switch (this.Tag) {
                case NodeTag.div: op = "/"; break;
                case NodeTag.minus: op = "-"; break;
                case NodeTag.plus: op = "+"; break;
                case NodeTag.rem: op = "%"; break;
                case NodeTag.mul: op = "*"; break;
            }
            return String.Format("({0} {1} {2})", this.lhs.Unparse(), op, this.rhs.Unparse());
        }
    }
    // ==================================================================================
}

